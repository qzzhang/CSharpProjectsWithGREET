using System;
using System.Collections.Generic;
using System.Reflection;

namespace Greet.DataStructureV4.Interfaces
{
    /// <summary>
    /// Class used to manipulate the data without having to worry about too many details and dependencies
    /// </summary>
    [Obfuscation(Feature = "renaming", Exclude = true)]
    public interface IDataHelper
    {
        #region factories
        /// <summary>
        /// Creates a new instance of a Pathway WITHOUT adding it to the dataset
        /// </summary>
        /// <param name="name">Optional name for the created pathway</param>
        /// <returns>New instance of pathway</returns>
        IPathway CreateNewPathway(string name = "", string notes = "");
        /// <summary>
        /// Creates a new instance of a process either stationary or transportation
        /// </summary>
        /// <param name="type">0 for stationary, 1 for transportation</param>
        /// <param name="name">Optional name for the newly created process</param>
        /// <returns>Null if type is not 0 nor 1, otherwise an instance of a new Process</returns>
        IProcess CreateNewProcess(int type, string name = "", string notes = "");
        /// <summary>
        /// Creates a new input if resource ID exists in the database, returns null otherwise
        /// </summary>
        /// <param name="resourceId">ID of an existing resource</param>
        /// <param name="errorMessage">Errors or warning message, can be used to diagnose issues</param>
        /// <param name="amount">Design amount for the input</param>
        /// <param name="quantity">Quantity for the design amount</param>
        /// <param name="source">Source of the input, 0=Well, 1=Previous, 2=Pathway, 3=Mix</param>
        /// <returns>New instance of Input or null</returns>
        IInput CreateNewInput(int resourceId, double amount = 0, string quantity = "joules", int source = 0, int pathOrMix = -1);
        /// <summary>
        /// Creates a new output if the resource ID exists in the database, returns null otherwise
        /// </summary>
        /// <param name="resourceId">ID of an existing resource</param>
        /// <param name="amount">Design amount for the output</param>
        /// <param name="quantity">Quantity for the design amount</param>
        /// <returns>New instance of Output or null</returns>
        IIO CreateNewMainOutput(int resourceId, double amount = 0, string quantity = "joules");
        /// <summary>
        /// Creates a new output if the resource ID exists in the database, returns null otherwise
        /// </summary>
        /// <param name="resourceId">ID of an existing resource</param>
        /// <param name="amount">Design amount for the output</param>
        /// <param name="quantity">Quantity for the design amount</param>
        /// <returns>New instance of Output or null</returns>
        IIO CreateNewCoProduct(int resourceId, double amount = 0, string quantity = "joules");
        /// <summary>
        /// Creates a new instance of a resource given a name for that resource
        /// </summary>
        /// <param name="name">Optional name for the resource</param>
        /// <returns>New instance of the created resource</returns>
        IResource CreateNewResource(string name = "", string notes = "");
        /// <summary>
        /// Creates a new instance of a transportation step for use in a transportation process
        /// </summary>
        /// <param name="mode">The ID of the mode to be used for that step</param>
        /// <param name="share">The mass share of the thoughput transported resource</param>
        /// <param name="m">The distance for that step</param>
        /// <param name="errorMessage">Potential problems during the construction of the new step</param>
        /// <param name="urbanShare">The urban share for the emissions generated by that step</param>
        /// <param name="processFuel">The process fuel selection, -1 will use the default fuel share</param>
        /// <returns>Newly created transportation step or null</returns>
        ITransportationStep CreateNewTStep(int mode, double share, double distance, double urbanShare = 0, int processFuel = 1);
        /// <summary>
        /// Creates a new instance of a mix with a given name;
        /// </summary>
        /// <param name="name">Name for the mix to be created</param>
        /// <returns>Instance of a mix</returns>
        IMix CreateNewMix(string name, string notes = "");
        /// <summary>
        /// Creates a new instance of a technology for use in a process inptut or transportation mode
        /// </summary>
        /// <param name="name">Desired name for the new technology</param>
        /// <returns>Newly created technology</returns>
        ITechnology CreateNewTechnology(string name, string notes = "");
        /// <summary>
        /// Creates a new pollutant that can be used for technology emission factors or other emissions
        /// </summary>
        /// <param name="name">Name of the pollutant</param>
        /// <param name="notes">Notes associated with that pollutant</param>
        /// <returns>Instance of a new pollutant</returns>
        IGas CreateNewPollutant(string name, string notes = "");
        #endregion

        #region data manipulation
        /// <summary>
        /// Tries to insert a pathway in the database, checks for validity before insertion
        /// If a pathway with the same ID is already inserted, then overwrites the existing one with the new pathway given as a parameter
        /// </summary>
        /// <param name="pathway">Pathway to be inserted</param>
        /// <param name="errorMessage">Error messages if any when checking the integrity of that pathway</param>
        /// <returns>True if pathway inserted correctly without any issues</returns>
        bool DataInsertOrUpdatePathway(IPathway pathway);
        /// <summary>
        /// Tries to insert a process in the database, checks for validity before insertion
        /// If a process with the same ID is already inserted, then overwrites the existing one with the new process given as a parameter
        /// </summary>
        /// <param name="process">Process to be inserted</param>
        /// <param name="errorMessage">Error messages if any when checking the integrity of that process</param>
        /// <returns></returns>
        bool DataInsertOrUpdateProcess(IProcess process);
        /// <summary>
        /// Inserts a new resource in the database or replace the one with the same ID if it already exists
        /// </summary>
        /// <param name="resource">The new resource to be added or used as an update</param>
        /// <returns>True if insertion was done</returns>
        bool DataInsertOrUpdateResource(IResource resource);
        /// <summary>
        /// Inserts the technology to the database or update an existing one that has the same ID
        /// </summary>
        /// <param name="technology">The technology to be inserted</param>
        /// <returns>True if successfully inserted, false otherwise</returns>
        bool DataInsertOrUpdateTechnology(ITechnology technology);
        /// <summary>
        /// Removes a process from the database. Will throw an exception if the process is used in any pathway
        /// </summary>
        /// <param name="process">The process to be removed from the database</param>
        /// <param name="force">If true, will simply remove it and will not throw exceptions</param>
        /// <returns>True if removed, false if wasn't in the database</returns>
        bool DataRemoveProcess(IProcess process, bool force = false);
        /// <summary>
        /// Removes a pathway from the database. Will throw an exception if the pathway is used in any pathway or mix
        /// </summary>
        /// <param name="process">The pathway to be removed from the database</param>
        /// <param name="force">If true, will simply remove it and will not throw exceptions</param>
        /// <returns>True if removed, false if wasn't in the database</returns>
        bool DataRemovePathway(IPathway pathway, bool force = false);
        /// <summary>
        /// Removes a resource from the database. Will throw an exception if the resource is used anywhere
        /// </summary>
        /// <param name="process">The resource to be removed from the database</param>
        /// <param name="force">If true, will simply remove it and will not throw exceptions</param>
        /// <returns>True if removed, false if wasn't in the database</returns>
        bool DataremoveResource(IResource resource, bool force = false);
        /// <summary>
        /// Inserts a mix to the database after checking it's integrity
        /// </summary>
        /// <param name="mix">The mix to be inserted to the database</param>
        bool DataInsertOrUpdateMix(IMix mix);
        /// <summary>
        /// Removes a mix from the database. Will throw an exception if the mix is used in any pathway or mix
        /// </summary>
        /// <param name="process">The mix to be removed from the database</param>
        /// <param name="force">If true, will simply remove it and will not throw exceptions</param>
        /// <returns>True if removed, false if wasn't in the database</returns>
        bool DataRemoveMix(IMix mix, bool force = false);
        /// <summary>
        /// Removes a technology from the database. Will throw an exception if the technology is used in any process or transportation mode
        /// </summary>
        /// <param name="process">The technology to be removed from the database</param>
        /// <param name="force">If true, will simply remove it and will not throw exceptions</param>
        /// <returns>True if removed, false if wasn't in the database</returns>
        bool DataRemoveTechnology(ITechnology technology, bool force = false);
        /// <summary>
        /// Inserts a pollutant to the database after checking it's integrity
        /// </summary>
        /// <param name="pollutant">The pollutant to be inserted</param>
        /// <returns>True if inserted correctly</returns>
        bool DataInsertOrUpdatePollutant(IGas pollutant);
        /// <summary>
        /// Creates a new vertex within a pathway to use a process model
        /// </summary>
        /// <param name="path">The pathway in which we want to create a new vertex</param>
        /// <param name="proc">The process model that is going to be used for that vertex</param>
        /// <returns>The created vertex if inserted successfully</returns>
        IVertex PathwayAddModel(IPathway path, IProcess proc);
        /// <summary>
        /// Creates a connector between an output of a process and an input of a process
        /// </summary>
        /// <param name="path">The pathway that contains the processes</param>
        /// <param name="procr">The vertex that contains the output (source of the connector)</param>
        /// <param name="outp">The outptut ID in the model represented by the vertex</param>
        /// <param name="proct">The vertex that contains the input (destination of the connector)</param>
        /// <param name="inp">The input ID in the model represented by the vertex</param>
        /// <returns>True if successfully added, false if a connector with the same connection was already defined in the pathway</returns>
        bool PathwayAddConnector(IPathway path, Guid origin, Guid outp, Guid destination, Guid inp);
        /// <summary>
        /// Creates an output for a pathway that can be connected to the output of a process and expose an upstream outside of the pathway
        /// </summary>
        /// <param name="path">The pathway that we want to modify by adding an output</param>
        /// <param name="CRUDE_RES_ID">The resource ID for the output that will be created</param>
        /// <returns>Instance of the PMOutput created for this pathway</returns>
        IIO PathwayCreateOutput(IPathway path, int CRUDE_RES_ID);
        /// <summary>
        /// Adds a connector between an output of a process and a pathway output
        /// </summary>
        /// <param name="path">The pathway that contains the processes</param>
        /// <param name="guid">The vertex that contains the output (source of the connector)</param>
        /// <param name="outS">The outptut ID in the model represented by the vertex</param>
        /// <param name="pathOut">The outptut ID of the pathway</param>
        /// <returns>True if successfully added, false if a connector with the same connection was already defined in the pathway</returns>
        bool PathwayAddConnector(IPathway pathway, Guid origin, Guid outp, Guid pathOut);
        /// <summary>
        /// Sets which output is the main output of the pathway
        /// </summary>
        /// <param name="pathway">The pathway to be modified</param>
        /// <param name="pathOut">The pathway output to be used as main output</param>
        bool PathwaySetMainOutput(IPathway pathway, Guid pathOut);
        /// <summary>
        /// Sets the carbon ratio of a pollutant to a certain value
        /// </summary>
        /// <param name="pollutant">The pollutant being modified</param>
        /// <param name="value">The mass ratio of Carbon in the pollutant</param>
        /// <returns>True if the value has been set properly</returns>
        bool PollutantSetCRatio(IGas pollutant, double value);
        /// <summary>
        /// Sets the sulfur ratio of a pollutant to a certain value
        /// </summary>
        /// <param name="pollutant">The pollutant being modified</param>
        /// <param name="value">The mass ratio of Sulfur in the pollutant</param>
        /// <returns>True if the value has been set properly</returns>
        bool PollutantSetSRatio(IGas pollutant, double value);
        /// <summary>
        /// Sets the global warming potential of a pollutant to a certain value
        /// </summary>
        /// <param name="pollutant">The pollutant being modified</param>
        /// <param name="value">The global warming potential relatively to CO2</param>
        /// <returns>True if the value has been set properly</returns>
        bool PollutantSetGWP100(IGas pollutant, double value);
        /// Inserts an input to a StationaryProcess only if the Input is either and InputWithShare
        /// or if the input is an Input
        /// </summary>
        /// <param name="process">Stationary process to which the input is going to be added</param>
        /// <param name="input">The instance of an input to add to the process</param>
        /// <param name="toGroup">If input is an instance on Input, setting to true will add in process Group, ignored otherwise</param>
        /// <param name="errorMessage">Error message for insertion or errors detected in the process integrity after insertion</param>
        /// <param name="autoCarbonEstimate">If true the carbon relations between inputs and outputs will be automatically adjusted</param>
        /// <returns>True if added to the process, false otherwise</returns>
        bool ProcessAddInput(IProcess process, IInput input, bool toGroup, bool autoCarbonEstimate = true);
        /// <summary>
        /// <para>If the output is a MainOutput, sets or update the existing main output of the process</para>
        /// <para>If the output is a CoProduct, adds or update an existing co-product that outputs the same resource ID</para>
        /// </summary>
        /// <param name="process">Process to which we want to add an output(Main output or co-product)</param>
        /// <param name="output">Output to be added to the process</param>
        /// <param name="errorMessage">Error messages if any errors</param>
        /// <param name="autoCarbonEstimate">If true the carbon relations between inputs and outputs will be automatically adjusted</param>
        /// <returns>True if inserted or updated, false otherwise</returns>
        bool ProcessAddOrUpdateOutput(IProcess process, IIO output, bool autoCarbonEstimate = true);
        /// <summary>
        /// Removes an input from a stationary process
        /// </summary>
        /// <param name="process">The process to be modified</param>
        /// <param name="input">The input to be removed</param>
        /// <returns>True if removed, false if the input is not part of that process</returns>
        bool ProcessRemoveInput(IProcess process, IInput input);
        /// <summary>
        /// Removes an output from a stationary process
        /// </summary>
        /// <param name="process"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        bool ProcessRemoveOutput(IProcess process, IIO output);
        /// <summary>
        /// Adds another emission item to a stationary process, this can be used to add emissions that are not related to technologies.
        /// </summary>
        /// <param name="process">The stationary process to which we desire to add other emissions</param>
        /// <param name="gasId">The ID of the emission we desire to add</param>
        /// <param name="quantity">The amount in kilograms we desire to add</param>
        /// <returns>True if added as a new emission</returns>
        bool ProcessAddOtherEmission(IProcess process, int gasId, double quantity);
        /// <summary>
        /// Sets the density of a resource by specifying the unit and quantiy
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="unit">The desired unit for the density</param>
        /// <param name="value">The desired value for the density</param>
        /// <returns>True if the density has been updated</returns>
        bool ResourceSetDensity(IResource resource, string unit, double value);
        /// <summary>
        /// Set the notes for a resource
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="notes">Notes to be set</param>
        /// <returns>True if notes have been set correctly</returns>
        bool ResourceSetNotes(IResource resource, string notes);
        /// <summary>
        /// Sets the Is Primary flag of a resource
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="value">The value of that flag</param>
        /// <returns>True if the flag has been set correctly</returns>
        bool ResourceSetIsPrimary(IResource resource, bool value);
        /// <summary>
        /// <para>Sets the sulfur ratio on a scale from 0 to 1</para>
        /// <para>Sulfur ratio is a time series. If the year argument is left to 0 the default year will be updated.</para>
        /// <para>If the year argument given exists in the time series, the corresponding sulfur ratio will be updated.</para>
        /// <para>If the year argument given does not exists in the time seres, a new sulfur ratio will be created for that year</para>
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="value">The 0-1 value of the sulfur ratio</param>
        /// <param name="year">Optional year value to be added as Sulfur Ratio is a time series parameter, leave at 0 for default year</param>
        /// <returns>True if the value has been set correctly</returns>
        bool ResourceSetSRatio(IResource resource, double value, int year = 0);
        /// <summary>
        /// Sets the Higher heating value for a resource
        /// </summary>
        /// <param name="resource">The resource beeing modified</param>
        /// <param name="unit">The unit for the higher heating value</param>
        /// <param name="value">The value in for the higher heating value</param>
        /// <returns>True if the heating value has been set correctly</returns>
        bool ResourceSetHHV(IResource resource, string unit, double value);
        /// <summary>
        /// Sets the physical state of the resource
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="physicalState">The desired physical state for that resource</param>
        /// <returns>True if the physical state has been set correctly</returns>
        bool ResourceSetState(IResource resource, Entities.Resources.PhysicalState physicalState);
        /// <summary>
        /// Sets the carbon ratio for a resource using a 0 to 1 value
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="value">The 0-1 value for the carbon ratio</param>
        /// <returns>True if the value has been set correctly</returns>
        bool ResourceSetCRatio(IResource resource, double value);
        /// <summary>
        /// Sets the lower heating value for the resource
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="unit">The unit for the lower heating value</param>
        /// <param name="value">The value for the lower heating value</param>
        /// <returns></returns>
        bool ResourceSetLHV(IResource resource, string unit, int value);
        /// <summary>
        /// Sets to null the lower heating value. This is necessary if the resource has no heating value.
        /// If the user sets a heating value of 0, GREET will use this to convert all quantities to zero.
        /// If the lower heating value is unset or null, GREET will not perform any conversion and will keep the original quantities
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <returns>True if successfully set to null</returns>
        bool ResourceUnsetLHV(IResource resource);
        /// <summary>
        /// Sets to null the higher heating value. This is necessary if the resource has no heating value.
        /// If the user sets a heating value of 0, GREET will use this to convert all quantities to zero.
        /// If the higher heating value is unset or null, GREET will not perform any conversion and will keep the original quantities
        /// </summary>
        /// <param name="resource">The resource being modified<param>
        /// <returns>True if successfully set to null</returns>
        bool ResourceUnsetHVV(IResource resource);
        /// <summary>
        /// Sets to null the density. This is necessary if the resource has no density.
        /// If the users sets a density of 0, GREET will use it to perform conversion and may end up with zeros.
        /// If the density is unset or null, GREET will not perform any conversion and will keep the original quantities
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <returns>True if successfully set to null</returns>
        bool ResourceUnsetDensity(IResource resource);
        /// <summary>
        /// Sets the market value for a resource
        /// </summary>
        /// <param name="resource">The resource being modified</param>
        /// <param name="unit">The unit for the market value</param>
        /// <param name="value">The value of the market value</param>
        /// <returns>True if the market value is correctly initialized</returns>
        bool ResourceSetMarketValue(IResource resource, string unit, double value);
        /// <summary>
        /// Adds a new year to the technology for all pollutants
        /// </summary>
        /// <param name="tech">The technology object to be modified</param>
        /// <param name="year">The new year to be added i.e. 2023</param>
        /// <returns></returns>
        bool TechnologyAddYear(ITechnology tech, int year);
        /// <summary>
        /// Sets the resource being combusted/used by the technology
        /// </summary>
        /// <param name="technology">The technology to be modified</param>
        /// <param name="resource">The resource ID to be assigned to that technology</param>
        /// <returns></returns>
        bool TechnologySetResource(ITechnology technology, int resource);
        /// <summary>
        /// Adds an emission factor to the current technology
        /// </summary>
        /// <param name="technology"></param>
        /// <param name="gas"></param>
        /// <returns></returns>
        bool TechnologyAddEmission(ITechnology technology, IGas gas);
        /// <summary>
        /// Retrieves an emission factor from a technology given a year and pollutant id
        /// </summary>
        /// <param name="technology">The technology from which we want to retrive this emission factor</param>
        /// <param name="year">The Year for which we want to get the emission factor</param>
        /// <param name="pollutantID">The ID of the pollutant for which we want to get the emission factor</param>
        /// <returns>The emission factor if found, null if no emission factor exists for the given year and pollutant id</returns>
        IParameter TechnologyGetEF(ITechnology technology, int yearValue, int pollutantID);
        /// <summary>
        /// Sets the value of an emission factor for a given year and pollutant id
        /// Creates a new emission factor if it was not previously an instance of an object
        /// </summary>
        /// <param name="technology">The technology being modified</param>
        /// <param name="year">The Year for which we want to get the emission factor</param>
        /// <param name="pollutantID">The ID of the pollutant for which we want to get the emission factor</param>
        /// <param name="unit">The unit for the emission factor</param>
        /// <param name="value">The value for the emission factor</param>
        /// <returns>True if successfully modified</returns>
        bool TechnologySetEF(ITechnology technology, int yearValue, int pollutantID, string unit, double value);
        /// <summary>
        /// Adds a transportation step to a transportation process
        /// </summary>
        /// <param name="process">The transportation process to be manipulated</param>
        /// <param name="step">The step to be added to the transportation process</param>
        /// <param name="message">Error messages in case the addition went wrong</param>
        bool TransportationAddTStep(IProcess process, ITransportationStep step);
        /// <summary>
        /// Add connector between a process and a location in a transportation step
        /// </summary>
        /// <param name="process">The transportation process to be manipulated</param>
        /// <param name="start">The origin for the connection</param>
        /// <param name="end">The end for the connection</param>
        bool TransportationAddConnector(ILocation start, ITransportationStep end);
        /// <summary>
        /// Add connector between a process and a location in a transportation step
        /// </summary>
        /// <param name="process">The transportation process to be manipulated</param>
        /// <param name="start">The origin for the connection</param>
        /// <param name="end">The end for the connection</param>
        bool TransportationAddConnector(ITransportationStep start, ILocation end);
        /// <summary>
        /// <para>Removes a transportation step from a transportation process</para>
        /// <para>This also removes the associated connectors</para>
        /// </summary>
        /// <param name="process">The process being modified</param>
        /// <param name="step">The step being removed</param>
        /// <returns>True if the step was removed, false if the step cannot be found in that process</returns>
        bool TransportationRemoveStep(IProcess process, ITransportationStep step);
        /// <summary>
        /// <para>Removes a location from a transportation process</para>
        /// <para>This also removes the associated connectors</para>
        /// </summary>
        /// <param name="process">The process being modified</param>
        /// <param name="location">The location being removed</param>
        /// <returns>True if the step was removed, false if the location cannot be found in that process</returns>
        bool TransportationRemoveLocation(IProcess process, ILocation location);
        /// <summary>
        /// Removes a connector from a transportation process
        /// </summary>
        /// <param name="process">The process being modifed</param>
        /// <param name="start">The start of the connector as a transportation step</param>
        /// <param name="end">The end of the connector as a location</param>
        /// <returns>True if the connector was removed, false otherwise</returns>
        bool TransportationRemoveConnector(IProcess process, ITransportationStep start, ILocation end);
        /// <summary>
        /// Removes a connector from a transportation process
        /// </summary>
        /// <param name="process">The process being modifed</param>
        /// <param name="start">The start of the connector as a location</param>
        /// <param name="end">The end of the connector as a transportation step</param>
        /// <returns>True if the connector was removed, false otherwise</returns>
        bool TransportationRemoveConnector(IProcess process, ILocation start, ITransportationStep end);
        /// <summary>
        /// Sets the resource being transported by a transportation process, returns true if succeeded, false otherwise
        /// </summary>
        /// <param name="process">The process for which we want to change the transported resource</param>
        /// <param name="p">The transported resource ID</param>
        /// <returns>True if successfully changed</returns>
        bool TransportationSetResource(IProcess process, int p);
        /// <summary>
        /// Modifies a mix by adding to it a pathway and a share
        /// </summary>
        /// <param name="mix">The mix to be modified</param>
        /// <param name="pathway">The source for the upstream added to that mix</param>
        /// <param name="share">The share for the source added to that mix</param>
        /// <returns>True if success, false if the pathways is already there</returns>
        bool MixAddFeed(IMix mix, IPathway pathway, double share = 0);       
        /// <summary>
        /// Modifies a mix by adding to it a mix and a share
        /// </summary>
        /// <param name="mix">The mix to be modified</param>
        /// <param name="pathway">The source for the upstream added to that mix</param>
        /// <param name="share">The share for the source added to that mix</param>
        /// <returns>True if success, false if the mix is already there</returns>
        bool MixAddFeed(IMix mix, IMix mix1, double p);
        /// <summary>
        /// Sets the output resource ID for the mix
        /// </summary>
        /// <param name="mix">The mix to be modified</param>
        /// <param name="resourceId">The resource id to be set as the main output</param>
        /// <returns>True if success, false otherwise</returns>
        bool MixSetResource(IMix mix, int resourceId);       
        /// <summary>
        /// Adds a technology to the input of a stationary process
        /// </summary>
        /// <param name="input">The input being modified</param>
        /// <param name="techId">The ID of the technology to add</param>
        /// <param name="share">The energy share 0-1 for that technology</param>
        /// <returns>True if the technology has been added, false if the same technology is already there</returns>
        bool InputAddTechnology(IInput input, int techId, double share = 0);
        /// <summary>
        /// Removes a technology from an input of a stationary process
        /// </summary>
        /// <param name="input">The input being modified</param>
        /// <param name="techId">The ID of the technology to be removed</param>
        /// <returns>True if the technology has been removed, false if a technology with that ID couldn't be found</returns>
        bool InputRemoveTechnology(IInput input, int techId);
       
        #endregion

        #region duplicators
        /// <summary>
        /// Creates a copy of a pathway with an identical structure but a whole new set of IDs
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        IPathway DuplicatePathway(IPathway o);
        /// <summary>
        /// Creates a copy of a stationary process with an identical structure but new IDs and parameters
        /// </summary>
        /// <param name="stationaryProcess">The process to be duplicated</param>
        /// <returns>The new instance of a duplicated process</returns>
        IStationaryProcess DuplicateStationaryProcess(IStationaryProcess stationaryProcess);
        /// <summary>
        /// Creates a new instance of a mix with a new ID and new output ID
        /// Takes care of registering all parameters and assiging new IDs
        /// </summary>
        /// <param name="mix">The mix to be duplicated</param>
        /// <returns>A new instance of the mix</returns>
        IMix DuplicateMix(IMix mix);
        /// <summary>
        /// Creates a copy of a transportation process with an identical structure but new IDs and parameters
        /// </summary>
        /// <param name="transportationProcess">The process to be duplicated</param>
        /// <returns>The new instance of a duplicated process</returns>
        ITransportationProcess DuplicateTransportationProcess(ITransportationProcess transportationProcess);
        #endregion

        #region Dependencies Finder and Used/Unused methods

        #region Pathways
        /// <summary>
        /// This method returns a list of pathways that are un-used by other parts of the sofware.
        /// In other words there is no other entitiy in Greet that is dependent on these pathways.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> unUsedPathways();
        /// <summary>
        /// This method returns a list of pathways that are used by other parts of the software.
        /// In other words there are entities in Greet dependent on the exisitence of these pathways.
        /// </summary>
        /// <param name="excludeVehicles">If set to true, this method will not account pathway used when only used within a vehicle (transportation modes and anythnig else is still accounted as used)</param>
        /// <param name="excludeMix0">If set to true, this method will not account pathways used only withing a mix with a share of zero<s/param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> usedPathways(bool excludeVehicles = false, bool excludeMix0 = false);
        /// <summary>
        /// List all instances that are dependent of the Pathway passed as a argument
        /// </summary>
        /// <param name="pathway">The pathway for which we want to know all the dependencies</param>
        /// <param name="output">Optional GUID for the output that we want to test. If empty all outputs are considered</param>
        /// <param name="excludeVehicles">If set to true, this method will nto account pathway used when only used within a vehicle (transportation modes and anythnig else is still accounted as used)</param>
        /// <param name="excludeMix">If set to true, this method will not account pathways used only withing a mix with a share of zero<s/param>
        /// <param name="returnASAP">If set to TRUE, the method will return when it hits the first dependency</param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<IDependentItem> PathwayDependentItems(IDependentItem pathway, Guid output = new Guid(), bool excludeVehicles = false, bool excludeMix = false, bool returnASAP = false);
        /// <summary>
        /// List of all data that is discarded.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> discardedPathways();
        #endregion

        #region Technology
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> unUsedTechnologies();
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> usedTechnologies();
        /// <summary>
        /// 
        /// </summary>
        /// <param name="idi"></param>
        /// <param name="returnASAP">If set to TRUE, the method will return when it hits the first dependency</param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<IDependentItem> TechnologyDependentItems(IDependentItem idi, bool returnASAP = true);
        /// <summary>
        /// List of all data that is discarded.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> discardedTechnologies();
        #endregion

        #region Process
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> usedProcesses();
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> unUsedProcesses();
        /// <summary>
        /// Checks if a process is used in pathways, if the io Guid is provided we'll only check for the specified io
        /// otherwise we'll check for any of the input or outputs.
        /// </summary>
        /// <param name="idi">Process IDependentItem</param>
        /// <param name="io">Specific IO GUID if necessary to check only for a specific edge, keep new Guid() if not deisred to specify</param>
        /// <param name="returnASAP">If set to TRUE, the method will return when it hits the first dependency</param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<IDependentItem> ProcessDependentItems(IDependentItem idi, Guid io = new Guid(), bool returnASAP = false);
        /// <summary>
        /// List of all data that is discarded.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> discardedProcesses();
        #endregion

        #region Mixes
        /// <summary>
        /// This method returns a list of mixes that are un-used by other parts of the sofware.
        /// In other words there is no other entitiy in Greet that is dependent on these mixes.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> unUsedMixes();
        /// <summary>
        /// This method returns a list of mixes that are used by other parts of the software.
        /// In other words there are entities in Greet dependent on the exisitence of these mixes.
        /// </summary>
        /// <param name="excludeParameters">If set to true, the method will not check if parameters from that mix are used in formulas for other parameters in the model</param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> usedMixes(bool excludeParameters = false);
        /// <summary>
        /// List of all data that is dependent on the inputted object.
        /// </summary>
        /// <param name="idi">Mix dependent item</param>
        /// <param name="excludeParameters">If set to true, the method will not check if parameters from that mix are used in formulas for other parameters in the model</param>
        /// <param name="returnASAP">If set to TRUE, the method will return when it hits the first dependency</param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<IDependentItem> MixDependentItems(IDependentItem idi, bool excludeParameters = false, bool returnASAP = false);
        /// <summary>
        /// List of all data that is discarded.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> discardedMixes();
        #endregion

        #region Resources
        /// <summary>
        /// This method returns a list of resources that are un-used by other parts of the sofware.
        /// In other words there is no other entitiy in Greet that is dependent on these resources.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> unUsedResources();
        /// <summary>
        /// This method returns a list of resources that are used by other parts of the software.
        /// In other words there are entities in Greet dependent on the exisitence of these resources.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> usedResources();
        /// <summary>
        /// List of all data that is dependent on the inputted object.
        /// </summary>
        /// <param name="r"></param>
        /// <param name="returnASAP">If set to TRUE, the method will return when it hits the first dependency</param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<IDependentItem> ResourceDependentItems(IDependentItem r, bool returnASAP = false);
        /// <summary>
        /// List of all data that is discarded.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> discardedResources();
        #endregion

        #region Vehicle
        /// <summary>
        /// This method returns a list of vehicles that are un-used by other parts of the sofware.
        /// In other words there is no other entitiy in Greet that is dependent on these vehicles.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> unUsedVehicles();
        /// <summary>
        /// This method returns a list of vehicles that are used by other parts of the software.
        /// In other words there are entities in Greet dependent on the exisitence of these vehicles.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> usedVehicles();
        /// <summary>
        /// List of all data that is dependent on the inputted object.
        /// </summary>
        /// <param name="idi"></param>
        /// <param name="returnASAP">If set to TRUE, the method will return when it hits the first dependency</param>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<IDependentItem> VehicleDependentItems(IDependentItem idi, bool returnASAP = false);
        /// <summary>
        /// List of all data that is discarded.
        /// </summary>
        /// <returns></returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<int> discardedVehicles();
        #endregion

        #endregion

        #region specific methods
        /// <summary>
        /// This is a list of all mixes and pathways that output a given resource.
        /// </summary>
        /// <param name="resourceId">The resource id whose list of possible ways is needed</param>
        /// <returns>The return type is a list of InputResourceReference's because this object can represent a pathway or a mix depending on the source attribute of the object</returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        List<IInputResourceReference> ProduceResource(int resourceId);

        /// <summary>
        /// This is a list of all mixes and pathways that output a given resource.
        /// </summary>
        /// <param name="resourceId">The resource id whose list of possible ways is needed</param>
        /// <returns>The return type is a list of InputResourceReference's because this object can represent a pathway or a mix depending on the source attribute of the object</returns>
        [Obfuscation(Feature = "renaming", Exclude = true)]
        int PathwayMainOutputResouce(int pathwayID);
        #endregion

        /// <summary>
        /// Creates a new instance of a transportation mode based on a certain type
        /// </summary>
        /// <param name="type">1=Tanker, 2=Truck, 3=Pipeline, 4=Rail, 5=Magic</param>
        /// <param name="name">Name for the new mode</param>
        /// <param name="notes">Notes associated with the mode</param>
        /// <returns>The newly created mode</returns>
        IAMode CreateNewMode(int type, string name, string notes = "");
        /// <summary>
        /// <para>Creates or updates a specific EI for a given resource ID.</para>
        /// <para>For pipeline, resource groups (such as liquid) or individual resources, can have a unique EI for the pipelines.</para>
        /// </summary>
        /// <param name="pipeBased">Pipeline being modified</param>
        /// <param name="id">Resource or Resource Group ID</param>
        /// <param name="unit">Unit for the EO, typically energy/distance/mass</param>
        /// <param name="value">Value of the EI in the given energy</param>
        /// <returns>True if the EI has been set for the given resource or resource group ID</returns>
        bool ModePipelineInsertOrUpdateEI(IAMode pipeBased, int id, string unit, int value);
        /// <summary>
        /// Adds a new energy source to a fuel share given by the fuelshare id
        /// </summary>
        /// <param name="mode">The mode being modified</param>
        /// <param name="fsId">The fuel share Id beeing modified. Should be set to 1 for the default fuel share</param>
        /// <param name="resourceId">The resource ID of the fuel to be added to that fuel share</param>
        /// <param name="share">The energy share 0-1 to be assigned to that fuel</param>
        /// <param name="pathOrMixId">The pathway or mix ID to be used for the production of the fuel/resource</param>
        /// <param name="source">Source for the pathOrMixID: 2=pathway, 3=mix</param>
        /// <param name="techToId">Technology used for the trip TO destination</param>
        /// <param name="techFromId">Technology used for the trip FROM destination</param>
        /// <returns>True if the resource has been added to the fuel share</returns>
        bool ModeAddEnergySource(IAMode mode, int fsId, int resourceId, double share, int pathOrMixId, int source, int techToId, int techFromId);
        /// <summary>
        /// Inserts a mode in the dataset after checking it's integrity
        /// </summary>
        /// <param name="mode">The mode to be added to the database</param>
        /// <returns>True if added correctly</returns>
        bool DataInsertOrUpdateMode(IAMode mode);
        /// <summary>
        /// Sets the average speed for a mode based on the tanker/barge model
        /// </summary>
        /// <param name="tankerBased">Tanker based mode being modified</param>
        /// <param name="unit">Unit for the average speed</param>
        /// <param name="p2">Value of the average speed in the given unit</param>
        /// <returns>True if the load factor has been set correctly</returns>
        bool ModeTankerSetAvgSpd(IAMode tankerBased, string unit, double value);
        /// <summary>
        /// Sets the engine power load factor from for a mode based on the tanker/barge
        /// </summary>
        /// <param name="tankerBased">Tanker based mode being modified</param>
        /// <param name="value">Engine power load factor 0-1</param>
        /// <returns>True if the load factor has been set correctly</returns>
        bool ModeTankerSetLoadFactorFrom(IAMode tankerBased, double value);
        /// <summary>
        /// Sets the fuel consumption TO destination for a truck based mode
        /// </summary>
        /// <param name="truckBased">Mode being modified</param>
        /// <param name="unit">Unit of the fuel consumption</param>
        /// <param name="value">Value of the fuel consumption</param>
        /// <returns>True if the fuel consumption TO has been set for the truck based mode</returns>
        bool ModeTruckSetFuelConsumptionTo(IAMode truckBased, string unit, double value);
        /// <summary>
        /// Inserts or update a payload for the truck. If a payload for the given resource ID is not defined, a new one will be created.
        /// Otherwise the payload associated with the given resource ID will be updated
        /// </summary>
        /// <param name="truckBased">Mode being modified</param>
        /// <param name="resId">Resource ID of transported payload</param>
        /// <param name="unit">Unit for the payload value</param>
        /// <param name="value">Value in the given unit for the payload mass</param>
        /// <returns>True if the payload has been added or updated</returns>
        bool ModeTruckInsertOrUpdatePayload(IAMode truckBased, int resId, string unit, double value);
        /// <summary>
        /// Set the engine power load factor TO destination for a tanker/barge based mode
        /// </summary>
        /// <param name="tankerBased">The mode being modified</param>
        /// <param name="factor">The power engine load factor</param>
        /// <returns>True if the load factor has been set</returns>
        bool ModeTankerSetLoadFactorTo(IAMode tankerBased, double factor);
        /// <summary>
        /// Sets the engine typical fuel consumption for a tanker/barge based mode
        /// </summary>
        /// <param name="tankerBased">The mode being modified</param>
        /// <param name="unit">Unit for the typical fuel consumption</param>
        /// <param name="value">Value of the typical fuel consumption</param>
        /// <returns>True if the fuel consumption has been set</returns>
        bool ModeTankerSetTypicalFuelConsumption(IAMode tankerBased, string unit, double value);
        /// <summary>
        /// Sets the engine typical horsepower
        /// </summary>
        /// <param name="tankerBased">The mode being modified</param>
        /// <param name="unit">Unit for the engine power</param>
        /// <param name="value">Value for the engine power</param>
        /// <returns>True if the engine power has been set</returns>
        bool ModeTankerSetTypicalHP(IAMode tankerBased, string unit, double value);
        /// <summary>
        /// Sets the HP/Payload factor for the ocean tanker which adjusts the engine power requirement according to the payload
        /// </summary>
        /// <param name="tankerBased">The mode being modified</param>
        /// <param name="unit">Unit of the HP/Payload factor</param>
        /// <param name="value">Value of the factor</param>
        /// <returns>True if the HP/Payload factor has been set</returns>
        bool ModeTankerSetHPPayloadFactor(IAMode tankerBased, string unit, double value);
        /// <summary>
        /// Inserts or Update a payload for the Tanker/Barge mode. Creates a new one if the resource id isn't there alread
        /// or update an existing payload for a given resource Id
        /// </summary>
        /// <param name="tankerBased">The mode being modified</param>
        /// <param name="resId">Resource ID for the transported payload</param>
        /// <param name="unit">Unit of mass for the payload</param>
        /// <param name="value">Value of the payload in the given unit</param>
        /// <returns>True if the payload has been set or added</returns>
        bool ModeTankerInsertOrUpdatePayload(IAMode tankerBased, int resId, string unit, double value);
        /// <summary>
        /// Sets fuel consumption from destination
        /// </summary>
        /// <param name="truckBased">The mode being modified</param>
        /// <param name="unit">Unit of the fuel consumption value</param>
        /// <param name="value">Value of the fuel consumption</param>
        /// <returns>True if the fuel consumption has been set</returns>
        bool ModeTruckSetFuelConsumptionFrom(IAMode truckBased, string unit, double value);
        /// <summary>
        /// Sets the average speed for a Rail-based mode
        /// </summary>
        /// <param name="railBased">The mode being modified</param>
        /// <param name="unit">Unit of the average speed value</param>
        /// <param name="value">Average speed value for the rail-based mode</param>
        /// <returns>True if the average speed has been set</returns>
        bool ModeRailSetAvgSpd(IAMode railBased, string unit, double value);
        /// <summary>
        /// Sets the EI for a Rail-based mode. If set with a resource ID, 
        /// </summary>
        /// <param name="railBased">The mode being modified</param>
        /// <param name="resOrGrpId">Resource Id or Resource Group Id</param>
        /// <param name="unit">The unit for the average speed value</param>
        /// <param name="value">The average speed value in the given unit</param>
        /// <returns>True if the average speed has been set</returns>
        bool ModeRailSetEI(IAMode railBased, int resOrGrpId, string unit, double value);
        /// <summary>
        /// Creates a new instance of a mode fuel share for use in a mode
        /// </summary>
        /// <param name="mode">The mode to which we desire to add a new fuel share</param>
        /// <param name="name">The name for the new fuel share</param>
        /// <param name="notes">Notes associated with the new fuel share</param>
        /// <returns>True if the fuel share has been created</returns>
        IModeFuelShares ModeCreateNewFuelShare(IAMode mode, string name, string notes = "");
        /// <summary>
        /// Inserts a new fuel share for a mode. Throws an exceptions with a fuel share already exists with the same ID
        /// </summary>
        /// <param name="mode">Mode being modified</param>
        /// <param name="fs">Fuel share to insert</param>
        /// <returns>True if inserted to the mode</returns>
        bool ModeInsertFuelShare(IAMode mode, IModeFuelShares fs);

    }
}
